/* tslint:disable */
/* eslint-disable */
/**
 * Gitea API.
 * This documentation describes the Gitea API.
 *
 * OpenAPI spec version: 1.14.0&#43;dev-693-g487f2ee41
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { APIError } from '../models';
import { AddCollaboratorOption } from '../models';
import { AnnotatedTag } from '../models';
import { Attachment } from '../models';
import { Branch } from '../models';
import { BranchProtection } from '../models';
import { CombinedStatus } from '../models';
import { Commit } from '../models';
import { CommitStatus } from '../models';
import { ContentsResponse } from '../models';
import { CreateBranchProtectionOption } from '../models';
import { CreateBranchRepoOption } from '../models';
import { CreateFileOptions } from '../models';
import { CreateForkOption } from '../models';
import { CreateHookOption } from '../models';
import { CreateKeyOption } from '../models';
import { CreatePullRequestOption } from '../models';
import { CreatePullReviewOptions } from '../models';
import { CreateReleaseOption } from '../models';
import { CreateRepoOption } from '../models';
import { CreateStatusOption } from '../models';
import { DeleteFileOptions } from '../models';
import { DeployKey } from '../models';
import { DismissPullReviewOptions } from '../models';
import { EditAttachmentOptions } from '../models';
import { EditBranchProtectionOption } from '../models';
import { EditGitHookOption } from '../models';
import { EditHookOption } from '../models';
import { EditPullRequestOption } from '../models';
import { EditReleaseOption } from '../models';
import { EditRepoOption } from '../models';
import { FileDeleteResponse } from '../models';
import { FileResponse } from '../models';
import { GitBlobResponse } from '../models';
import { GitHook } from '../models';
import { GitTreeResponse } from '../models';
import { Hook } from '../models';
import { IssueTemplate } from '../models';
import { MergePullRequestOption } from '../models';
import { MigrateRepoOptions } from '../models';
import { PullRequest } from '../models';
import { PullReview } from '../models';
import { PullReviewComment } from '../models';
import { PullReviewRequestOptions } from '../models';
import { Reference } from '../models';
import { Release } from '../models';
import { RepoTopicOptions } from '../models';
import { Repository } from '../models';
import { SearchResults } from '../models';
import { SubmitPullReviewOptions } from '../models';
import { Tag } from '../models';
import { Team } from '../models';
import { TopicName } from '../models';
import { TopicResponse } from '../models';
import { TrackedTime } from '../models';
import { TransferRepoOption } from '../models';
import { UpdateFileOptions } from '../models';
import { User } from '../models';
import { WatchInfo } from '../models';
/**
 * RepositoryApi - axios parameter creator
 * @export
 */
export const RepositoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a repository
         * @param {CreateRepoOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrentUserRepo: async (body?: CreateRepoOption, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/repos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Fork a repository
         * @param {string} owner owner of the repo to fork
         * @param {string} repo name of the repo to fork
         * @param {CreateForkOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFork: async (owner: string, repo: string, body?: CreateForkOption, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createFork.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling createFork.');
            }
            const localVarPath = `/repos/{owner}/{repo}/forks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets the blob of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlob: async (owner: string, repo: string, sha: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getBlob.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling getBlob.');
            }
            // verify required parameter 'sha' is not null or undefined
            if (sha === null || sha === undefined) {
                throw new RequiredError('sha','Required parameter sha was null or undefined when calling getBlob.');
            }
            const localVarPath = `/repos/{owner}/{repo}/git/blobs/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets the tag object of an annotated tag (not lightweight tags)
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag: async (owner: string, repo: string, sha: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getTag.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling getTag.');
            }
            // verify required parameter 'sha' is not null or undefined
            if (sha === null || sha === undefined) {
                throw new RequiredError('sha','Required parameter sha was null or undefined when calling getTag.');
            }
            const localVarPath = `/repos/{owner}/{repo}/git/tags/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets the tree of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {boolean} [recursive] show all directories and files
         * @param {number} [page] page number; the &#x27;truncated&#x27; field in the response will be true if there are still more items after this page, false if the last page
         * @param {number} [perPage] number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTree: async (owner: string, repo: string, sha: string, recursive?: boolean, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getTree.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling getTree.');
            }
            // verify required parameter 'sha' is not null or undefined
            if (sha === null || sha === undefined) {
                throw new RequiredError('sha','Required parameter sha was null or undefined when calling getTree.');
            }
            const localVarPath = `/repos/{owner}/{repo}/git/trees/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List a repository's forks
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForks: async (owner: string, repo: string, page?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listForks.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling listForks.');
            }
            const localVarPath = `/repos/{owner}/{repo}/forks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Add a collaborator to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to add
         * @param {AddCollaboratorOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddCollaborator: async (owner: string, repo: string, collaborator: string, body?: AddCollaboratorOption, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoAddCollaborator.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoAddCollaborator.');
            }
            // verify required parameter 'collaborator' is not null or undefined
            if (collaborator === null || collaborator === undefined) {
                throw new RequiredError('collaborator','Required parameter collaborator was null or undefined when calling repoAddCollaborator.');
            }
            const localVarPath = `/repos/{owner}/{repo}/collaborators/{collaborator}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"collaborator"}}`, encodeURIComponent(String(collaborator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Add a team to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddTeam: async (owner: string, repo: string, team: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoAddTeam.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoAddTeam.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling repoAddTeam.');
            }
            const localVarPath = `/repos/{owner}/{repo}/teams/{team}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Add a topic to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddTopc: async (owner: string, repo: string, topic: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoAddTopc.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoAddTopc.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling repoAddTopc.');
            }
            const localVarPath = `/repos/{owner}/{repo}/topics/{topic}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Check if a user is a collaborator of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCheckCollaborator: async (owner: string, repo: string, collaborator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCheckCollaborator.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCheckCollaborator.');
            }
            // verify required parameter 'collaborator' is not null or undefined
            if (collaborator === null || collaborator === undefined) {
                throw new RequiredError('collaborator','Required parameter collaborator was null or undefined when calling repoCheckCollaborator.');
            }
            const localVarPath = `/repos/{owner}/{repo}/collaborators/{collaborator}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"collaborator"}}`, encodeURIComponent(String(collaborator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Check if a team is assigned to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCheckTeam: async (owner: string, repo: string, team: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCheckTeam.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCheckTeam.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling repoCheckTeam.');
            }
            const localVarPath = `/repos/{owner}/{repo}/teams/{team}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a branch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchRepoOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateBranch: async (owner: string, repo: string, body?: CreateBranchRepoOption, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreateBranch.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreateBranch.');
            }
            const localVarPath = `/repos/{owner}/{repo}/branches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchProtectionOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateBranchProtection: async (owner: string, repo: string, body?: CreateBranchProtectionOption, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreateBranchProtection.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreateBranchProtection.');
            }
            const localVarPath = `/repos/{owner}/{repo}/branch_protections`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a file in a repository
         * @param {CreateFileOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateFile: async (body: CreateFileOptions, owner: string, repo: string, filepath: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling repoCreateFile.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreateFile.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreateFile.');
            }
            // verify required parameter 'filepath' is not null or undefined
            if (filepath === null || filepath === undefined) {
                throw new RequiredError('filepath','Required parameter filepath was null or undefined when calling repoCreateFile.');
            }
            const localVarPath = `/repos/{owner}/{repo}/contents/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateHookOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateHook: async (owner: string, repo: string, body?: CreateHookOption, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreateHook.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreateHook.');
            }
            const localVarPath = `/repos/{owner}/{repo}/hooks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Add a key to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateKeyOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateKey: async (owner: string, repo: string, body?: CreateKeyOption, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreateKey.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreateKey.');
            }
            const localVarPath = `/repos/{owner}/{repo}/keys`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreatePullRequestOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullRequest: async (owner: string, repo: string, body?: CreatePullRequestOption, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreatePullRequest.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreatePullRequest.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a review to an pull request
         * @param {CreatePullReviewOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullReview: async (body: CreatePullReviewOptions, owner: string, repo: string, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling repoCreatePullReview.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreatePullReview.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreatePullReview.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoCreatePullReview.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary create review requests for a pull request
         * @param {PullReviewRequestOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullReviewRequests: async (body: PullReviewRequestOptions, owner: string, repo: string, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling repoCreatePullReviewRequests.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreatePullReviewRequests.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreatePullReviewRequests.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoCreatePullReviewRequests.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/requested_reviewers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateReleaseOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateRelease: async (owner: string, repo: string, body?: CreateReleaseOption, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreateRelease.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreateRelease.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a release attachment
         * @param {string} attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateReleaseAttachment: async (attachment: string, owner: string, repo: string, id: number, name?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'attachment' is not null or undefined
            if (attachment === null || attachment === undefined) {
                throw new RequiredError('attachment','Required parameter attachment was null or undefined when calling repoCreateReleaseAttachment.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreateReleaseAttachment.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreateReleaseAttachment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoCreateReleaseAttachment.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


            if (attachment !== undefined) {
                localVarFormParams.append('attachment', attachment as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a commit status
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {CreateStatusOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateStatus: async (owner: string, repo: string, sha: string, body?: CreateStatusOption, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreateStatus.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreateStatus.');
            }
            // verify required parameter 'sha' is not null or undefined
            if (sha === null || sha === undefined) {
                throw new RequiredError('sha','Required parameter sha was null or undefined when calling repoCreateStatus.');
            }
            const localVarPath = `/repos/{owner}/{repo}/statuses/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a repository
         * @param {string} owner owner of the repo to delete
         * @param {string} repo name of the repo to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDelete: async (owner: string, repo: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDelete.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDelete.');
            }
            const localVarPath = `/repos/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a specific branch from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteBranch: async (owner: string, repo: string, branch: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteBranch.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteBranch.');
            }
            // verify required parameter 'branch' is not null or undefined
            if (branch === null || branch === undefined) {
                throw new RequiredError('branch','Required parameter branch was null or undefined when calling repoDeleteBranch.');
            }
            const localVarPath = `/repos/{owner}/{repo}/branches/{branch}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteBranchProtection: async (owner: string, repo: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteBranchProtection.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteBranchProtection.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling repoDeleteBranchProtection.');
            }
            const localVarPath = `/repos/{owner}/{repo}/branch_protections/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a collaborator from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteCollaborator: async (owner: string, repo: string, collaborator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteCollaborator.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteCollaborator.');
            }
            // verify required parameter 'collaborator' is not null or undefined
            if (collaborator === null || collaborator === undefined) {
                throw new RequiredError('collaborator','Required parameter collaborator was null or undefined when calling repoDeleteCollaborator.');
            }
            const localVarPath = `/repos/{owner}/{repo}/collaborators/{collaborator}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"collaborator"}}`, encodeURIComponent(String(collaborator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a file in a repository
         * @param {DeleteFileOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteFile: async (body: DeleteFileOptions, owner: string, repo: string, filepath: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling repoDeleteFile.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteFile.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteFile.');
            }
            // verify required parameter 'filepath' is not null or undefined
            if (filepath === null || filepath === undefined) {
                throw new RequiredError('filepath','Required parameter filepath was null or undefined when calling repoDeleteFile.');
            }
            const localVarPath = `/repos/{owner}/{repo}/contents/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteGitHook: async (owner: string, repo: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteGitHook.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteGitHook.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoDeleteGitHook.');
            }
            const localVarPath = `/repos/{owner}/{repo}/hooks/git/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteHook: async (owner: string, repo: string, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteHook.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteHook.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoDeleteHook.');
            }
            const localVarPath = `/repos/{owner}/{repo}/hooks/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a key from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteKey: async (owner: string, repo: string, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteKey.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteKey.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoDeleteKey.');
            }
            const localVarPath = `/repos/{owner}/{repo}/keys/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a specific review from a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeletePullReview: async (owner: string, repo: string, index: number, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeletePullReview.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeletePullReview.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoDeletePullReview.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoDeletePullReview.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary cancel review requests for a pull request
         * @param {PullReviewRequestOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeletePullReviewRequests: async (body: PullReviewRequestOptions, owner: string, repo: string, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling repoDeletePullReviewRequests.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeletePullReviewRequests.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeletePullReviewRequests.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoDeletePullReviewRequests.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/requested_reviewers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteRelease: async (owner: string, repo: string, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteRelease.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteRelease.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoDeleteRelease.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteReleaseAttachment: async (owner: string, repo: string, id: number, attachmentId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteReleaseAttachment.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteReleaseAttachment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoDeleteReleaseAttachment.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling repoDeleteReleaseAttachment.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteReleaseByTag: async (owner: string, repo: string, tag: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteReleaseByTag.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteReleaseByTag.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling repoDeleteReleaseByTag.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases/tags/{tag}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a repository's tag by name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTag: async (owner: string, repo: string, tag: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteTag.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteTag.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling repoDeleteTag.');
            }
            const localVarPath = `/repos/{owner}/{repo}/tags/{tag}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a team from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTeam: async (owner: string, repo: string, team: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteTeam.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteTeam.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling repoDeleteTeam.');
            }
            const localVarPath = `/repos/{owner}/{repo}/teams/{team}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a topic from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTopic: async (owner: string, repo: string, topic: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteTopic.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling repoDeleteTopic.');
            }
            const localVarPath = `/repos/{owner}/{repo}/topics/{topic}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Dismiss a review for a pull request
         * @param {DismissPullReviewOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDismissPullReview: async (body: DismissPullReviewOptions, owner: string, repo: string, index: number, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling repoDismissPullReview.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDismissPullReview.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDismissPullReview.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoDismissPullReview.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoDismissPullReview.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/dismissals`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a pull request diff
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDownloadPullDiff: async (owner: string, repo: string, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDownloadPullDiff.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDownloadPullDiff.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoDownloadPullDiff.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}.diff`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a pull request patch file
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDownloadPullPatch: async (owner: string, repo: string, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDownloadPullPatch.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDownloadPullPatch.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoDownloadPullPatch.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}.patch`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Edit a repository's properties. Only fields that are set will be changed.
         * @param {string} owner owner of the repo to edit
         * @param {string} repo name of the repo to edit
         * @param {EditRepoOption} [body] Properties of a repo that you can edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEdit: async (owner: string, repo: string, body?: EditRepoOption, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoEdit.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoEdit.');
            }
            const localVarPath = `/repos/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Edit a branch protections for a repository. Only fields that are set will be changed
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {EditBranchProtectionOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditBranchProtection: async (owner: string, repo: string, name: string, body?: EditBranchProtectionOption, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoEditBranchProtection.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoEditBranchProtection.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling repoEditBranchProtection.');
            }
            const localVarPath = `/repos/{owner}/{repo}/branch_protections/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Edit a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {EditGitHookOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditGitHook: async (owner: string, repo: string, id: string, body?: EditGitHookOption, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoEditGitHook.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoEditGitHook.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoEditGitHook.');
            }
            const localVarPath = `/repos/{owner}/{repo}/hooks/git/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Edit a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id index of the hook
         * @param {EditHookOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditHook: async (owner: string, repo: string, id: number, body?: EditHookOption, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoEditHook.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoEditHook.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoEditHook.');
            }
            const localVarPath = `/repos/{owner}/{repo}/hooks/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to edit
         * @param {EditPullRequestOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditPullRequest: async (owner: string, repo: string, index: number, body?: EditPullRequestOption, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoEditPullRequest.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoEditPullRequest.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoEditPullRequest.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to edit
         * @param {EditReleaseOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditRelease: async (owner: string, repo: string, id: number, body?: EditReleaseOption, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoEditRelease.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoEditRelease.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoEditRelease.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Edit a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditReleaseAttachment: async (owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoEditReleaseAttachment.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoEditReleaseAttachment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoEditReleaseAttachment.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling repoEditReleaseAttachment.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGet: async (owner: string, repo: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGet.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGet.');
            }
            const localVarPath = `/repos/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a list of all commits from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [sha] SHA or branch to start listing commits from (usually &#x27;master&#x27;)
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetAllCommits: async (owner: string, repo: string, sha?: string, page?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetAllCommits.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetAllCommits.');
            }
            const localVarPath = `/repos/{owner}/{repo}/commits`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (sha !== undefined) {
                localVarQueryParameter['sha'] = sha;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get an archive of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} archive the git reference for download with attached archive format (e.g. master.zip)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetArchive: async (owner: string, repo: string, archive: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetArchive.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetArchive.');
            }
            // verify required parameter 'archive' is not null or undefined
            if (archive === null || archive === undefined) {
                throw new RequiredError('archive','Required parameter archive was null or undefined when calling repoGetArchive.');
            }
            const localVarPath = `/repos/{owner}/{repo}/archive/{archive}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"archive"}}`, encodeURIComponent(String(archive)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieve a specific branch from a repository, including its effective branch protection
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetBranch: async (owner: string, repo: string, branch: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetBranch.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetBranch.');
            }
            // verify required parameter 'branch' is not null or undefined
            if (branch === null || branch === undefined) {
                throw new RequiredError('branch','Required parameter branch was null or undefined when calling repoGetBranch.');
            }
            const localVarPath = `/repos/{owner}/{repo}/branches/{branch}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetBranchProtection: async (owner: string, repo: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetBranchProtection.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetBranchProtection.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling repoGetBranchProtection.');
            }
            const localVarPath = `/repos/{owner}/{repo}/branch_protections/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a repository by id
         * @param {number} id id of the repo to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetByID: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoGetByID.');
            }
            const localVarPath = `/repositories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a commit's combined status, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetCombinedStatusByRef: async (owner: string, repo: string, ref: string, page?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetCombinedStatusByRef.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetCombinedStatusByRef.');
            }
            // verify required parameter 'ref' is not null or undefined
            if (ref === null || ref === undefined) {
                throw new RequiredError('ref','Required parameter ref was null or undefined when calling repoGetCombinedStatusByRef.');
            }
            const localVarPath = `/repos/{owner}/{repo}/commits/{ref}/status`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"ref"}}`, encodeURIComponent(String(ref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the dir, file, symlink or submodule in the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetContents: async (owner: string, repo: string, filepath: string, ref?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetContents.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetContents.');
            }
            // verify required parameter 'filepath' is not null or undefined
            if (filepath === null || filepath === undefined) {
                throw new RequiredError('filepath','Required parameter filepath was null or undefined when calling repoGetContents.');
            }
            const localVarPath = `/repos/{owner}/{repo}/contents/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets the metadata of all the entries of the root dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetContentsList: async (owner: string, repo: string, ref?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetContentsList.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetContentsList.');
            }
            const localVarPath = `/repos/{owner}/{repo}/contents`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get the EditorConfig definitions of a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of file to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetEditorConfig: async (owner: string, repo: string, filepath: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetEditorConfig.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetEditorConfig.');
            }
            // verify required parameter 'filepath' is not null or undefined
            if (filepath === null || filepath === undefined) {
                throw new RequiredError('filepath','Required parameter filepath was null or undefined when calling repoGetEditorConfig.');
            }
            const localVarPath = `/repos/{owner}/{repo}/editorconfig/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Git hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetGitHook: async (owner: string, repo: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetGitHook.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetGitHook.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoGetGitHook.');
            }
            const localVarPath = `/repos/{owner}/{repo}/hooks/git/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetHook: async (owner: string, repo: string, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetHook.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetHook.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoGetHook.');
            }
            const localVarPath = `/repos/{owner}/{repo}/hooks/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get available issue templates for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetIssueTemplates: async (owner: string, repo: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetIssueTemplates.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetIssueTemplates.');
            }
            const localVarPath = `/repos/{owner}/{repo}/issue_templates`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a repository's key by id
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetKey: async (owner: string, repo: string, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetKey.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetKey.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoGetKey.');
            }
            const localVarPath = `/repos/{owner}/{repo}/keys/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get languages and number of bytes of code written
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetLanguages: async (owner: string, repo: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetLanguages.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetLanguages.');
            }
            const localVarPath = `/repos/{owner}/{repo}/languages`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullRequest: async (owner: string, repo: string, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetPullRequest.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetPullRequest.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoGetPullRequest.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullReview: async (owner: string, repo: string, index: number, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetPullReview.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetPullReview.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoGetPullReview.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoGetPullReview.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullReviewComments: async (owner: string, repo: string, index: number, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetPullReviewComments.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetPullReviewComments.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoGetPullReviewComments.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoGetPullReviewComments.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/comments`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a file from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRawFile: async (owner: string, repo: string, filepath: string, ref?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetRawFile.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetRawFile.');
            }
            // verify required parameter 'filepath' is not null or undefined
            if (filepath === null || filepath === undefined) {
                throw new RequiredError('filepath','Required parameter filepath was null or undefined when calling repoGetRawFile.');
            }
            const localVarPath = `/repos/{owner}/{repo}/raw/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRelease: async (owner: string, repo: string, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetRelease.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetRelease.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoGetRelease.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReleaseAttachment: async (owner: string, repo: string, id: number, attachmentId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetReleaseAttachment.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetReleaseAttachment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoGetReleaseAttachment.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling repoGetReleaseAttachment.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReleaseByTag: async (owner: string, repo: string, tag: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetReleaseByTag.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetReleaseByTag.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling repoGetReleaseByTag.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases/tags/{tag}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetSingleCommit: async (owner: string, repo: string, sha: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetSingleCommit.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetSingleCommit.');
            }
            // verify required parameter 'sha' is not null or undefined
            if (sha === null || sha === undefined) {
                throw new RequiredError('sha','Required parameter sha was null or undefined when calling repoGetSingleCommit.');
            }
            const localVarPath = `/repos/{owner}/{repo}/git/commits/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get specified ref or filtered repository's refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListAllGitRefs: async (owner: string, repo: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListAllGitRefs.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListAllGitRefs.');
            }
            const localVarPath = `/repos/{owner}/{repo}/git/refs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListBranchProtection: async (owner: string, repo: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListBranchProtection.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListBranchProtection.');
            }
            const localVarPath = `/repos/{owner}/{repo}/branch_protections`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List a repository's branches
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListBranches: async (owner: string, repo: string, page?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListBranches.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListBranches.');
            }
            const localVarPath = `/repos/{owner}/{repo}/branches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List a repository's collaborators
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListCollaborators: async (owner: string, repo: string, page?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListCollaborators.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListCollaborators.');
            }
            const localVarPath = `/repos/{owner}/{repo}/collaborators`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List the Git hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListGitHooks: async (owner: string, repo: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListGitHooks.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListGitHooks.');
            }
            const localVarPath = `/repos/{owner}/{repo}/hooks/git`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get specified ref or filtered repository's refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref part or full name of the ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListGitRefs: async (owner: string, repo: string, ref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListGitRefs.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListGitRefs.');
            }
            // verify required parameter 'ref' is not null or undefined
            if (ref === null || ref === undefined) {
                throw new RequiredError('ref','Required parameter ref was null or undefined when calling repoListGitRefs.');
            }
            const localVarPath = `/repos/{owner}/{repo}/git/refs/{ref}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"ref"}}`, encodeURIComponent(String(ref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List the hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListHooks: async (owner: string, repo: string, page?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListHooks.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListHooks.');
            }
            const localVarPath = `/repos/{owner}/{repo}/hooks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List a repository's keys
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [keyId] the key_id to search for
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListKeys: async (owner: string, repo: string, keyId?: number, fingerprint?: string, page?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListKeys.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListKeys.');
            }
            const localVarPath = `/repos/{owner}/{repo}/keys`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (keyId !== undefined) {
                localVarQueryParameter['key_id'] = keyId;
            }

            if (fingerprint !== undefined) {
                localVarQueryParameter['fingerprint'] = fingerprint;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List a repo's pull requests
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [state] State of pull request: open or closed (optional)
         * @param {string} [sort] Type of sort
         * @param {number} [milestone] ID of the milestone
         * @param {Array&lt;number&gt;} [labels] Label IDs
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPullRequests: async (owner: string, repo: string, state?: string, sort?: string, milestone?: number, labels?: Array<number>, page?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListPullRequests.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListPullRequests.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (milestone !== undefined) {
                localVarQueryParameter['milestone'] = milestone;
            }

            if (labels) {
                localVarQueryParameter['labels'] = labels;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List all reviews for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPullReviews: async (owner: string, repo: string, index: number, page?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListPullReviews.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListPullReviews.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoListPullReviews.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List release's attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListReleaseAttachments: async (owner: string, repo: string, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListReleaseAttachments.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListReleaseAttachments.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoListReleaseAttachments.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List a repo's releases
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [perPage] page size of results, deprecated - use limit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListReleases: async (owner: string, repo: string, perPage?: number, page?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListReleases.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListReleases.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List a repo's stargazers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStargazers: async (owner: string, repo: string, page?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListStargazers.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListStargazers.');
            }
            const localVarPath = `/repos/{owner}/{repo}/stargazers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a commit's statuses
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {string} [sort] type of sort
         * @param {string} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStatuses: async (owner: string, repo: string, sha: string, sort?: string, state?: string, page?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListStatuses.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListStatuses.');
            }
            // verify required parameter 'sha' is not null or undefined
            if (sha === null || sha === undefined) {
                throw new RequiredError('sha','Required parameter sha was null or undefined when calling repoListStatuses.');
            }
            const localVarPath = `/repos/{owner}/{repo}/statuses/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a commit's statuses, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {string} [sort] type of sort
         * @param {string} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStatusesByRef: async (owner: string, repo: string, ref: string, sort?: string, state?: string, page?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListStatusesByRef.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListStatusesByRef.');
            }
            // verify required parameter 'ref' is not null or undefined
            if (ref === null || ref === undefined) {
                throw new RequiredError('ref','Required parameter ref was null or undefined when calling repoListStatusesByRef.');
            }
            const localVarPath = `/repos/{owner}/{repo}/commits/{ref}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"ref"}}`, encodeURIComponent(String(ref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List a repo's watchers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListSubscribers: async (owner: string, repo: string, page?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListSubscribers.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListSubscribers.');
            }
            const localVarPath = `/repos/{owner}/{repo}/subscribers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List a repository's tags
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results, default maximum page size is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTags: async (owner: string, repo: string, page?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListTags.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListTags.');
            }
            const localVarPath = `/repos/{owner}/{repo}/tags`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List a repository's teams
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTeams: async (owner: string, repo: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListTeams.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListTeams.');
            }
            const localVarPath = `/repos/{owner}/{repo}/teams`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get list of topics that a repository has
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTopics: async (owner: string, repo: string, page?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListTopics.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListTopics.');
            }
            const localVarPath = `/repos/{owner}/{repo}/topics`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Merge a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {MergePullRequestOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMergePullRequest: async (owner: string, repo: string, index: number, body?: MergePullRequestOption, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoMergePullRequest.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoMergePullRequest.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoMergePullRequest.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/merge`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Migrate a remote git repository
         * @param {MigrateRepoOptions} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMigrate: async (body?: MigrateRepoOptions, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/repos/migrate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Sync a mirrored repository
         * @param {string} owner owner of the repo to sync
         * @param {string} repo name of the repo to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMirrorSync: async (owner: string, repo: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoMirrorSync.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoMirrorSync.');
            }
            const localVarPath = `/repos/{owner}/{repo}/mirror-sync`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Check if a pull request has been merged
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoPullRequestIsMerged: async (owner: string, repo: string, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoPullRequestIsMerged.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoPullRequestIsMerged.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoPullRequestIsMerged.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/merge`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Search for repositories
         * @param {string} [q] keyword
         * @param {boolean} [topic] Limit search to repositories with keyword as topic
         * @param {boolean} [includeDesc] include search of keyword within repository description
         * @param {number} [uid] search only for repos that the user with the given id owns or contributes to
         * @param {number} [priorityOwnerId] repo owner to prioritize in the results
         * @param {number} [teamId] search only for repos that belong to the given team id
         * @param {number} [starredBy] search only for repos that the user with the given id has starred
         * @param {boolean} [_private] include private repositories this user has access to (defaults to true)
         * @param {boolean} [isPrivate] show only pubic, private or all repositories (defaults to all)
         * @param {boolean} [template] include template repositories this user has access to (defaults to true)
         * @param {boolean} [archived] show only archived, non-archived or all repositories (defaults to all)
         * @param {string} [mode] type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
         * @param {boolean} [exclusive] if &#x60;uid&#x60; is given, search only for repos that the user owns
         * @param {string} [sort] sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
         * @param {string} [order] sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSearch: async (q?: string, topic?: boolean, includeDesc?: boolean, uid?: number, priorityOwnerId?: number, teamId?: number, starredBy?: number, _private?: boolean, isPrivate?: boolean, template?: boolean, archived?: boolean, mode?: string, exclusive?: boolean, sort?: string, order?: string, page?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/repos/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (topic !== undefined) {
                localVarQueryParameter['topic'] = topic;
            }

            if (includeDesc !== undefined) {
                localVarQueryParameter['includeDesc'] = includeDesc;
            }

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }

            if (priorityOwnerId !== undefined) {
                localVarQueryParameter['priority_owner_id'] = priorityOwnerId;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (starredBy !== undefined) {
                localVarQueryParameter['starredBy'] = starredBy;
            }

            if (_private !== undefined) {
                localVarQueryParameter['private'] = _private;
            }

            if (isPrivate !== undefined) {
                localVarQueryParameter['is_private'] = isPrivate;
            }

            if (template !== undefined) {
                localVarQueryParameter['template'] = template;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (exclusive !== undefined) {
                localVarQueryParameter['exclusive'] = exclusive;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get signing-key.gpg for given repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSigningKey: async (owner: string, repo: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoSigningKey.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoSigningKey.');
            }
            const localVarPath = `/repos/{owner}/{repo}/signing-key.gpg`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Submit a pending review to an pull request
         * @param {SubmitPullReviewOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSubmitPullReview: async (body: SubmitPullReviewOptions, owner: string, repo: string, index: number, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling repoSubmitPullReview.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoSubmitPullReview.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoSubmitPullReview.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoSubmitPullReview.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoSubmitPullReview.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Test a push webhook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTestHook: async (owner: string, repo: string, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoTestHook.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoTestHook.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoTestHook.');
            }
            const localVarPath = `/repos/{owner}/{repo}/hooks/{id}/tests`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List a repo's tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {Date} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {Date} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTrackedTimes: async (owner: string, repo: string, user?: string, since?: Date, before?: Date, page?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoTrackedTimes.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoTrackedTimes.');
            }
            const localVarPath = `/repos/{owner}/{repo}/times`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Transfer a repo ownership
         * @param {TransferRepoOption} body Transfer Options
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTransfer: async (body: TransferRepoOption, owner: string, repo: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling repoTransfer.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoTransfer.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoTransfer.');
            }
            const localVarPath = `/repos/{owner}/{repo}/transfer`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Cancel to dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUnDismissPullReview: async (owner: string, repo: string, index: number, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoUnDismissPullReview.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoUnDismissPullReview.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoUnDismissPullReview.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoUnDismissPullReview.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/undismissals`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a file in a repository
         * @param {UpdateFileOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdateFile: async (body: UpdateFileOptions, owner: string, repo: string, filepath: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling repoUpdateFile.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoUpdateFile.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoUpdateFile.');
            }
            // verify required parameter 'filepath' is not null or undefined
            if (filepath === null || filepath === undefined) {
                throw new RequiredError('filepath','Required parameter filepath was null or undefined when calling repoUpdateFile.');
            }
            const localVarPath = `/repos/{owner}/{repo}/contents/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Merge PR's baseBranch into headBranch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdatePullRequest: async (owner: string, repo: string, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoUpdatePullRequest.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoUpdatePullRequest.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoUpdatePullRequest.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/update`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Replace list of topics for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {RepoTopicOptions} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdateTopics: async (owner: string, repo: string, body?: RepoTopicOptions, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoUpdateTopics.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoUpdateTopics.');
            }
            const localVarPath = `/repos/{owner}/{repo}/topics`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary search topics via keyword
         * @param {string} q keywords to search
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicSearch: async (q: string, page?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            if (q === null || q === undefined) {
                throw new RequiredError('q','Required parameter q was null or undefined when calling topicSearch.');
            }
            const localVarPath = `/topics/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Check if the current user is watching a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentCheckSubscription: async (owner: string, repo: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling userCurrentCheckSubscription.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling userCurrentCheckSubscription.');
            }
            const localVarPath = `/repos/{owner}/{repo}/subscription`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Unwatch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteSubscription: async (owner: string, repo: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling userCurrentDeleteSubscription.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling userCurrentDeleteSubscription.');
            }
            const localVarPath = `/repos/{owner}/{repo}/subscription`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Watch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPutSubscription: async (owner: string, repo: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling userCurrentPutSubscription.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling userCurrentPutSubscription.');
            }
            const localVarPath = `/repos/{owner}/{repo}/subscription`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List a user's tracked times in a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} user username of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTrackedTimes: async (owner: string, repo: string, user: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling userTrackedTimes.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling userTrackedTimes.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling userTrackedTimes.');
            }
            const localVarPath = `/repos/{owner}/{repo}/times/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoryApi - functional programming interface
 * @export
 */
export const RepositoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a repository
         * @param {CreateRepoOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCurrentUserRepo(body?: CreateRepoOption, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).createCurrentUserRepo(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Fork a repository
         * @param {string} owner owner of the repo to fork
         * @param {string} repo name of the repo to fork
         * @param {CreateForkOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFork(owner: string, repo: string, body?: CreateForkOption, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).createFork(owner, repo, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Gets the blob of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlob(owner: string, repo: string, sha: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitBlobResponse>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).getBlob(owner, repo, sha, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Gets the tag object of an annotated tag (not lightweight tags)
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTag(owner: string, repo: string, sha: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotatedTag>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).getTag(owner, repo, sha, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Gets the tree of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {boolean} [recursive] show all directories and files
         * @param {number} [page] page number; the &#x27;truncated&#x27; field in the response will be true if there are still more items after this page, false if the last page
         * @param {number} [perPage] number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTree(owner: string, repo: string, sha: string, recursive?: boolean, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitTreeResponse>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).getTree(owner, repo, sha, recursive, page, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary List a repository's forks
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listForks(owner: string, repo: string, page?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).listForks(owner, repo, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Add a collaborator to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to add
         * @param {AddCollaboratorOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoAddCollaborator(owner: string, repo: string, collaborator: string, body?: AddCollaboratorOption, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoAddCollaborator(owner, repo, collaborator, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Add a team to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoAddTeam(owner: string, repo: string, team: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoAddTeam(owner, repo, team, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Add a topic to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoAddTopc(owner: string, repo: string, topic: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoAddTopc(owner, repo, topic, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Check if a user is a collaborator of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCheckCollaborator(owner: string, repo: string, collaborator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCheckCollaborator(owner, repo, collaborator, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Check if a team is assigned to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCheckTeam(owner: string, repo: string, team: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCheckTeam(owner, repo, team, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Create a branch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchRepoOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateBranch(owner: string, repo: string, body?: CreateBranchRepoOption, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreateBranch(owner, repo, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Create a branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchProtectionOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateBranchProtection(owner: string, repo: string, body?: CreateBranchProtectionOption, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchProtection>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreateBranchProtection(owner, repo, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Create a file in a repository
         * @param {CreateFileOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateFile(body: CreateFileOptions, owner: string, repo: string, filepath: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileResponse>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreateFile(body, owner, repo, filepath, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Create a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateHookOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateHook(owner: string, repo: string, body?: CreateHookOption, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreateHook(owner, repo, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Add a key to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateKeyOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateKey(owner: string, repo: string, body?: CreateKeyOption, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployKey>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreateKey(owner, repo, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Create a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreatePullRequestOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreatePullRequest(owner: string, repo: string, body?: CreatePullRequestOption, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullRequest>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreatePullRequest(owner, repo, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Create a review to an pull request
         * @param {CreatePullReviewOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreatePullReview(body: CreatePullReviewOptions, owner: string, repo: string, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullReview>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreatePullReview(body, owner, repo, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary create review requests for a pull request
         * @param {PullReviewRequestOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreatePullReviewRequests(body: PullReviewRequestOptions, owner: string, repo: string, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullReview>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreatePullReviewRequests(body, owner, repo, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Create a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateReleaseOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateRelease(owner: string, repo: string, body?: CreateReleaseOption, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Release>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreateRelease(owner, repo, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Create a release attachment
         * @param {string} attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateReleaseAttachment(attachment: string, owner: string, repo: string, id: number, name?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreateReleaseAttachment(attachment, owner, repo, id, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Create a commit status
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {CreateStatusOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateStatus(owner: string, repo: string, sha: string, body?: CreateStatusOption, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitStatus>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreateStatus(owner, repo, sha, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a repository
         * @param {string} owner owner of the repo to delete
         * @param {string} repo name of the repo to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDelete(owner: string, repo: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDelete(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a specific branch from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteBranch(owner: string, repo: string, branch: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteBranch(owner, repo, branch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteBranchProtection(owner: string, repo: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteBranchProtection(owner, repo, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a collaborator from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteCollaborator(owner: string, repo: string, collaborator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteCollaborator(owner, repo, collaborator, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a file in a repository
         * @param {DeleteFileOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteFile(body: DeleteFileOptions, owner: string, repo: string, filepath: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileDeleteResponse>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteFile(body, owner, repo, filepath, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteGitHook(owner: string, repo: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteGitHook(owner, repo, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteHook(owner: string, repo: string, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteHook(owner, repo, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a key from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteKey(owner: string, repo: string, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteKey(owner, repo, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a specific review from a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeletePullReview(owner: string, repo: string, index: number, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeletePullReview(owner, repo, index, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary cancel review requests for a pull request
         * @param {PullReviewRequestOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeletePullReviewRequests(body: PullReviewRequestOptions, owner: string, repo: string, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeletePullReviewRequests(body, owner, repo, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteRelease(owner: string, repo: string, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteRelease(owner, repo, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteReleaseAttachment(owner, repo, id, attachmentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteReleaseByTag(owner: string, repo: string, tag: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteReleaseByTag(owner, repo, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a repository's tag by name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteTag(owner: string, repo: string, tag: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteTag(owner, repo, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a team from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteTeam(owner: string, repo: string, team: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteTeam(owner, repo, team, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a topic from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteTopic(owner: string, repo: string, topic: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteTopic(owner, repo, topic, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Dismiss a review for a pull request
         * @param {DismissPullReviewOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDismissPullReview(body: DismissPullReviewOptions, owner: string, repo: string, index: number, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullReview>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDismissPullReview(body, owner, repo, index, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a pull request diff
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDownloadPullDiff(owner: string, repo: string, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDownloadPullDiff(owner, repo, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a pull request patch file
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDownloadPullPatch(owner: string, repo: string, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDownloadPullPatch(owner, repo, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Edit a repository's properties. Only fields that are set will be changed.
         * @param {string} owner owner of the repo to edit
         * @param {string} repo name of the repo to edit
         * @param {EditRepoOption} [body] Properties of a repo that you can edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEdit(owner: string, repo: string, body?: EditRepoOption, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoEdit(owner, repo, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Edit a branch protections for a repository. Only fields that are set will be changed
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {EditBranchProtectionOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditBranchProtection(owner: string, repo: string, name: string, body?: EditBranchProtectionOption, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchProtection>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoEditBranchProtection(owner, repo, name, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Edit a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {EditGitHookOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditGitHook(owner: string, repo: string, id: string, body?: EditGitHookOption, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitHook>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoEditGitHook(owner, repo, id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Edit a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id index of the hook
         * @param {EditHookOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditHook(owner: string, repo: string, id: number, body?: EditHookOption, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoEditHook(owner, repo, id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to edit
         * @param {EditPullRequestOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditPullRequest(owner: string, repo: string, index: number, body?: EditPullRequestOption, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullRequest>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoEditPullRequest(owner, repo, index, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to edit
         * @param {EditReleaseOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditRelease(owner: string, repo: string, id: number, body?: EditReleaseOption, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Release>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoEditRelease(owner, repo, id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Edit a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoEditReleaseAttachment(owner, repo, id, attachmentId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGet(owner: string, repo: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGet(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a list of all commits from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [sha] SHA or branch to start listing commits from (usually &#x27;master&#x27;)
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetAllCommits(owner: string, repo: string, sha?: string, page?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Commit>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetAllCommits(owner, repo, sha, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get an archive of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} archive the git reference for download with attached archive format (e.g. master.zip)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetArchive(owner: string, repo: string, archive: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetArchive(owner, repo, archive, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Retrieve a specific branch from a repository, including its effective branch protection
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetBranch(owner: string, repo: string, branch: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetBranch(owner, repo, branch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetBranchProtection(owner: string, repo: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchProtection>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetBranchProtection(owner, repo, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a repository by id
         * @param {number} id id of the repo to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetByID(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetByID(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a commit's combined status, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetCombinedStatusByRef(owner: string, repo: string, ref: string, page?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CombinedStatus>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetCombinedStatusByRef(owner, repo, ref, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the dir, file, symlink or submodule in the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetContents(owner: string, repo: string, filepath: string, ref?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContentsResponse>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetContents(owner, repo, filepath, ref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Gets the metadata of all the entries of the root dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetContentsList(owner: string, repo: string, ref?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContentsResponse>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetContentsList(owner, repo, ref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get the EditorConfig definitions of a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of file to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetEditorConfig(owner: string, repo: string, filepath: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetEditorConfig(owner, repo, filepath, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a Git hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetGitHook(owner: string, repo: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitHook>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetGitHook(owner, repo, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetHook(owner: string, repo: string, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetHook(owner, repo, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get available issue templates for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetIssueTemplates(owner: string, repo: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IssueTemplate>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetIssueTemplates(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a repository's key by id
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetKey(owner: string, repo: string, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployKey>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetKey(owner, repo, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get languages and number of bytes of code written
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetLanguages(owner: string, repo: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number;}>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetLanguages(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullRequest(owner: string, repo: string, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullRequest>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetPullRequest(owner, repo, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullReview(owner: string, repo: string, index: number, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullReview>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetPullReview(owner, repo, index, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullReviewComments(owner: string, repo: string, index: number, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullReviewComment>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetPullReviewComments(owner, repo, index, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a file from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetRawFile(owner: string, repo: string, filepath: string, ref?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetRawFile(owner, repo, filepath, ref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetRelease(owner: string, repo: string, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Release>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetRelease(owner, repo, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetReleaseAttachment(owner, repo, id, attachmentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetReleaseByTag(owner: string, repo: string, tag: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Release>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetReleaseByTag(owner, repo, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetSingleCommit(owner: string, repo: string, sha: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Commit>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetSingleCommit(owner, repo, sha, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get specified ref or filtered repository's refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListAllGitRefs(owner: string, repo: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reference>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListAllGitRefs(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary List branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListBranchProtection(owner: string, repo: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BranchProtection>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListBranchProtection(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary List a repository's branches
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListBranches(owner: string, repo: string, page?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Branch>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListBranches(owner, repo, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary List a repository's collaborators
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListCollaborators(owner: string, repo: string, page?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListCollaborators(owner, repo, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary List the Git hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListGitHooks(owner: string, repo: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GitHook>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListGitHooks(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get specified ref or filtered repository's refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref part or full name of the ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListGitRefs(owner: string, repo: string, ref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reference>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListGitRefs(owner, repo, ref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary List the hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListHooks(owner: string, repo: string, page?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hook>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListHooks(owner, repo, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary List a repository's keys
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [keyId] the key_id to search for
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListKeys(owner: string, repo: string, keyId?: number, fingerprint?: string, page?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeployKey>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListKeys(owner, repo, keyId, fingerprint, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary List a repo's pull requests
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [state] State of pull request: open or closed (optional)
         * @param {string} [sort] Type of sort
         * @param {number} [milestone] ID of the milestone
         * @param {Array&lt;number&gt;} [labels] Label IDs
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListPullRequests(owner: string, repo: string, state?: string, sort?: string, milestone?: number, labels?: Array<number>, page?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullRequest>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListPullRequests(owner, repo, state, sort, milestone, labels, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary List all reviews for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListPullReviews(owner: string, repo: string, index: number, page?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullReview>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListPullReviews(owner, repo, index, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary List release's attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListReleaseAttachments(owner: string, repo: string, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Attachment>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListReleaseAttachments(owner, repo, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary List a repo's releases
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [perPage] page size of results, deprecated - use limit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListReleases(owner: string, repo: string, perPage?: number, page?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Release>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListReleases(owner, repo, perPage, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary List a repo's stargazers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListStargazers(owner: string, repo: string, page?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListStargazers(owner, repo, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a commit's statuses
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {string} [sort] type of sort
         * @param {string} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListStatuses(owner: string, repo: string, sha: string, sort?: string, state?: string, page?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommitStatus>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListStatuses(owner, repo, sha, sort, state, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a commit's statuses, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {string} [sort] type of sort
         * @param {string} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListStatusesByRef(owner: string, repo: string, ref: string, sort?: string, state?: string, page?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommitStatus>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListStatusesByRef(owner, repo, ref, sort, state, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary List a repo's watchers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListSubscribers(owner: string, repo: string, page?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListSubscribers(owner, repo, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary List a repository's tags
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results, default maximum page size is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListTags(owner: string, repo: string, page?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListTags(owner, repo, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary List a repository's teams
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListTeams(owner: string, repo: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Team>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListTeams(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get list of topics that a repository has
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListTopics(owner: string, repo: string, page?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopicName>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListTopics(owner, repo, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Merge a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {MergePullRequestOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoMergePullRequest(owner: string, repo: string, index: number, body?: MergePullRequestOption, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoMergePullRequest(owner, repo, index, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Migrate a remote git repository
         * @param {MigrateRepoOptions} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoMigrate(body?: MigrateRepoOptions, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoMigrate(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Sync a mirrored repository
         * @param {string} owner owner of the repo to sync
         * @param {string} repo name of the repo to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoMirrorSync(owner: string, repo: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoMirrorSync(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Check if a pull request has been merged
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoPullRequestIsMerged(owner: string, repo: string, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoPullRequestIsMerged(owner, repo, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Search for repositories
         * @param {string} [q] keyword
         * @param {boolean} [topic] Limit search to repositories with keyword as topic
         * @param {boolean} [includeDesc] include search of keyword within repository description
         * @param {number} [uid] search only for repos that the user with the given id owns or contributes to
         * @param {number} [priorityOwnerId] repo owner to prioritize in the results
         * @param {number} [teamId] search only for repos that belong to the given team id
         * @param {number} [starredBy] search only for repos that the user with the given id has starred
         * @param {boolean} [_private] include private repositories this user has access to (defaults to true)
         * @param {boolean} [isPrivate] show only pubic, private or all repositories (defaults to all)
         * @param {boolean} [template] include template repositories this user has access to (defaults to true)
         * @param {boolean} [archived] show only archived, non-archived or all repositories (defaults to all)
         * @param {string} [mode] type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
         * @param {boolean} [exclusive] if &#x60;uid&#x60; is given, search only for repos that the user owns
         * @param {string} [sort] sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
         * @param {string} [order] sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoSearch(q?: string, topic?: boolean, includeDesc?: boolean, uid?: number, priorityOwnerId?: number, teamId?: number, starredBy?: number, _private?: boolean, isPrivate?: boolean, template?: boolean, archived?: boolean, mode?: string, exclusive?: boolean, sort?: string, order?: string, page?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResults>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoSearch(q, topic, includeDesc, uid, priorityOwnerId, teamId, starredBy, _private, isPrivate, template, archived, mode, exclusive, sort, order, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get signing-key.gpg for given repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoSigningKey(owner: string, repo: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoSigningKey(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Submit a pending review to an pull request
         * @param {SubmitPullReviewOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoSubmitPullReview(body: SubmitPullReviewOptions, owner: string, repo: string, index: number, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullReview>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoSubmitPullReview(body, owner, repo, index, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Test a push webhook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoTestHook(owner: string, repo: string, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoTestHook(owner, repo, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary List a repo's tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {Date} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {Date} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoTrackedTimes(owner: string, repo: string, user?: string, since?: Date, before?: Date, page?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrackedTime>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoTrackedTimes(owner, repo, user, since, before, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Transfer a repo ownership
         * @param {TransferRepoOption} body Transfer Options
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoTransfer(body: TransferRepoOption, owner: string, repo: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoTransfer(body, owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Cancel to dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUnDismissPullReview(owner: string, repo: string, index: number, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullReview>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoUnDismissPullReview(owner, repo, index, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update a file in a repository
         * @param {UpdateFileOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUpdateFile(body: UpdateFileOptions, owner: string, repo: string, filepath: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileResponse>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoUpdateFile(body, owner, repo, filepath, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Merge PR's baseBranch into headBranch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUpdatePullRequest(owner: string, repo: string, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoUpdatePullRequest(owner, repo, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Replace list of topics for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {RepoTopicOptions} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUpdateTopics(owner: string, repo: string, body?: RepoTopicOptions, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoUpdateTopics(owner, repo, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary search topics via keyword
         * @param {string} q keywords to search
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topicSearch(q: string, page?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopicResponse>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).topicSearch(q, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Check if the current user is watching a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentCheckSubscription(owner: string, repo: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchInfo>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).userCurrentCheckSubscription(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Unwatch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentDeleteSubscription(owner: string, repo: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).userCurrentDeleteSubscription(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Watch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentPutSubscription(owner: string, repo: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchInfo>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).userCurrentPutSubscription(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary List a user's tracked times in a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} user username of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userTrackedTimes(owner: string, repo: string, user: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrackedTime>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).userTrackedTimes(owner, repo, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RepositoryApi - factory interface
 * @export
 */
export const RepositoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Create a repository
         * @param {CreateRepoOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrentUserRepo(body?: CreateRepoOption, options?: any): AxiosPromise<Repository> {
            return RepositoryApiFp(configuration).createCurrentUserRepo(body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Fork a repository
         * @param {string} owner owner of the repo to fork
         * @param {string} repo name of the repo to fork
         * @param {CreateForkOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFork(owner: string, repo: string, body?: CreateForkOption, options?: any): AxiosPromise<Repository> {
            return RepositoryApiFp(configuration).createFork(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets the blob of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlob(owner: string, repo: string, sha: string, options?: any): AxiosPromise<GitBlobResponse> {
            return RepositoryApiFp(configuration).getBlob(owner, repo, sha, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets the tag object of an annotated tag (not lightweight tags)
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(owner: string, repo: string, sha: string, options?: any): AxiosPromise<AnnotatedTag> {
            return RepositoryApiFp(configuration).getTag(owner, repo, sha, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets the tree of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {boolean} [recursive] show all directories and files
         * @param {number} [page] page number; the &#x27;truncated&#x27; field in the response will be true if there are still more items after this page, false if the last page
         * @param {number} [perPage] number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTree(owner: string, repo: string, sha: string, recursive?: boolean, page?: number, perPage?: number, options?: any): AxiosPromise<GitTreeResponse> {
            return RepositoryApiFp(configuration).getTree(owner, repo, sha, recursive, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List a repository's forks
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForks(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return RepositoryApiFp(configuration).listForks(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add a collaborator to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to add
         * @param {AddCollaboratorOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddCollaborator(owner: string, repo: string, collaborator: string, body?: AddCollaboratorOption, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoAddCollaborator(owner, repo, collaborator, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add a team to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddTeam(owner: string, repo: string, team: string, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoAddTeam(owner, repo, team, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add a topic to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddTopc(owner: string, repo: string, topic: string, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoAddTopc(owner, repo, topic, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Check if a user is a collaborator of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCheckCollaborator(owner: string, repo: string, collaborator: string, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoCheckCollaborator(owner, repo, collaborator, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Check if a team is assigned to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCheckTeam(owner: string, repo: string, team: string, options?: any): AxiosPromise<Team> {
            return RepositoryApiFp(configuration).repoCheckTeam(owner, repo, team, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a branch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchRepoOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateBranch(owner: string, repo: string, body?: CreateBranchRepoOption, options?: any): AxiosPromise<Branch> {
            return RepositoryApiFp(configuration).repoCreateBranch(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchProtectionOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateBranchProtection(owner: string, repo: string, body?: CreateBranchProtectionOption, options?: any): AxiosPromise<BranchProtection> {
            return RepositoryApiFp(configuration).repoCreateBranchProtection(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a file in a repository
         * @param {CreateFileOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateFile(body: CreateFileOptions, owner: string, repo: string, filepath: string, options?: any): AxiosPromise<FileResponse> {
            return RepositoryApiFp(configuration).repoCreateFile(body, owner, repo, filepath, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateHookOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateHook(owner: string, repo: string, body?: CreateHookOption, options?: any): AxiosPromise<Hook> {
            return RepositoryApiFp(configuration).repoCreateHook(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add a key to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateKeyOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateKey(owner: string, repo: string, body?: CreateKeyOption, options?: any): AxiosPromise<DeployKey> {
            return RepositoryApiFp(configuration).repoCreateKey(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreatePullRequestOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullRequest(owner: string, repo: string, body?: CreatePullRequestOption, options?: any): AxiosPromise<PullRequest> {
            return RepositoryApiFp(configuration).repoCreatePullRequest(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a review to an pull request
         * @param {CreatePullReviewOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullReview(body: CreatePullReviewOptions, owner: string, repo: string, index: number, options?: any): AxiosPromise<PullReview> {
            return RepositoryApiFp(configuration).repoCreatePullReview(body, owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary create review requests for a pull request
         * @param {PullReviewRequestOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullReviewRequests(body: PullReviewRequestOptions, owner: string, repo: string, index: number, options?: any): AxiosPromise<Array<PullReview>> {
            return RepositoryApiFp(configuration).repoCreatePullReviewRequests(body, owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateReleaseOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateRelease(owner: string, repo: string, body?: CreateReleaseOption, options?: any): AxiosPromise<Release> {
            return RepositoryApiFp(configuration).repoCreateRelease(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a release attachment
         * @param {string} attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateReleaseAttachment(attachment: string, owner: string, repo: string, id: number, name?: string, options?: any): AxiosPromise<Attachment> {
            return RepositoryApiFp(configuration).repoCreateReleaseAttachment(attachment, owner, repo, id, name, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a commit status
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {CreateStatusOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateStatus(owner: string, repo: string, sha: string, body?: CreateStatusOption, options?: any): AxiosPromise<CommitStatus> {
            return RepositoryApiFp(configuration).repoCreateStatus(owner, repo, sha, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a repository
         * @param {string} owner owner of the repo to delete
         * @param {string} repo name of the repo to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDelete(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoDelete(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a specific branch from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteBranch(owner: string, repo: string, branch: string, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoDeleteBranch(owner, repo, branch, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteBranchProtection(owner: string, repo: string, name: string, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoDeleteBranchProtection(owner, repo, name, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a collaborator from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteCollaborator(owner: string, repo: string, collaborator: string, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoDeleteCollaborator(owner, repo, collaborator, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a file in a repository
         * @param {DeleteFileOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteFile(body: DeleteFileOptions, owner: string, repo: string, filepath: string, options?: any): AxiosPromise<FileDeleteResponse> {
            return RepositoryApiFp(configuration).repoDeleteFile(body, owner, repo, filepath, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteGitHook(owner: string, repo: string, id: string, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoDeleteGitHook(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteHook(owner: string, repo: string, id: number, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoDeleteHook(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a key from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteKey(owner: string, repo: string, id: number, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoDeleteKey(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a specific review from a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeletePullReview(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoDeletePullReview(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary cancel review requests for a pull request
         * @param {PullReviewRequestOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeletePullReviewRequests(body: PullReviewRequestOptions, owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoDeletePullReviewRequests(body, owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteRelease(owner: string, repo: string, id: number, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoDeleteRelease(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoDeleteReleaseAttachment(owner, repo, id, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteReleaseByTag(owner: string, repo: string, tag: string, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoDeleteReleaseByTag(owner, repo, tag, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a repository's tag by name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTag(owner: string, repo: string, tag: string, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoDeleteTag(owner, repo, tag, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a team from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTeam(owner: string, repo: string, team: string, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoDeleteTeam(owner, repo, team, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a topic from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTopic(owner: string, repo: string, topic: string, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoDeleteTopic(owner, repo, topic, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Dismiss a review for a pull request
         * @param {DismissPullReviewOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDismissPullReview(body: DismissPullReviewOptions, owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<PullReview> {
            return RepositoryApiFp(configuration).repoDismissPullReview(body, owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a pull request diff
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDownloadPullDiff(owner: string, repo: string, index: number, options?: any): AxiosPromise<string> {
            return RepositoryApiFp(configuration).repoDownloadPullDiff(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a pull request patch file
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDownloadPullPatch(owner: string, repo: string, index: number, options?: any): AxiosPromise<string> {
            return RepositoryApiFp(configuration).repoDownloadPullPatch(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Edit a repository's properties. Only fields that are set will be changed.
         * @param {string} owner owner of the repo to edit
         * @param {string} repo name of the repo to edit
         * @param {EditRepoOption} [body] Properties of a repo that you can edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEdit(owner: string, repo: string, body?: EditRepoOption, options?: any): AxiosPromise<Repository> {
            return RepositoryApiFp(configuration).repoEdit(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Edit a branch protections for a repository. Only fields that are set will be changed
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {EditBranchProtectionOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditBranchProtection(owner: string, repo: string, name: string, body?: EditBranchProtectionOption, options?: any): AxiosPromise<BranchProtection> {
            return RepositoryApiFp(configuration).repoEditBranchProtection(owner, repo, name, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Edit a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {EditGitHookOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditGitHook(owner: string, repo: string, id: string, body?: EditGitHookOption, options?: any): AxiosPromise<GitHook> {
            return RepositoryApiFp(configuration).repoEditGitHook(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Edit a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id index of the hook
         * @param {EditHookOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditHook(owner: string, repo: string, id: number, body?: EditHookOption, options?: any): AxiosPromise<Hook> {
            return RepositoryApiFp(configuration).repoEditHook(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to edit
         * @param {EditPullRequestOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditPullRequest(owner: string, repo: string, index: number, body?: EditPullRequestOption, options?: any): AxiosPromise<PullRequest> {
            return RepositoryApiFp(configuration).repoEditPullRequest(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to edit
         * @param {EditReleaseOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditRelease(owner: string, repo: string, id: number, body?: EditReleaseOption, options?: any): AxiosPromise<Release> {
            return RepositoryApiFp(configuration).repoEditRelease(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Edit a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: any): AxiosPromise<Attachment> {
            return RepositoryApiFp(configuration).repoEditReleaseAttachment(owner, repo, id, attachmentId, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGet(owner: string, repo: string, options?: any): AxiosPromise<Repository> {
            return RepositoryApiFp(configuration).repoGet(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a list of all commits from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [sha] SHA or branch to start listing commits from (usually &#x27;master&#x27;)
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetAllCommits(owner: string, repo: string, sha?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Commit>> {
            return RepositoryApiFp(configuration).repoGetAllCommits(owner, repo, sha, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get an archive of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} archive the git reference for download with attached archive format (e.g. master.zip)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetArchive(owner: string, repo: string, archive: string, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoGetArchive(owner, repo, archive, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a specific branch from a repository, including its effective branch protection
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetBranch(owner: string, repo: string, branch: string, options?: any): AxiosPromise<Branch> {
            return RepositoryApiFp(configuration).repoGetBranch(owner, repo, branch, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetBranchProtection(owner: string, repo: string, name: string, options?: any): AxiosPromise<BranchProtection> {
            return RepositoryApiFp(configuration).repoGetBranchProtection(owner, repo, name, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a repository by id
         * @param {number} id id of the repo to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetByID(id: number, options?: any): AxiosPromise<Repository> {
            return RepositoryApiFp(configuration).repoGetByID(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a commit's combined status, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetCombinedStatusByRef(owner: string, repo: string, ref: string, page?: number, limit?: number, options?: any): AxiosPromise<CombinedStatus> {
            return RepositoryApiFp(configuration).repoGetCombinedStatusByRef(owner, repo, ref, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the dir, file, symlink or submodule in the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetContents(owner: string, repo: string, filepath: string, ref?: string, options?: any): AxiosPromise<ContentsResponse> {
            return RepositoryApiFp(configuration).repoGetContents(owner, repo, filepath, ref, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets the metadata of all the entries of the root dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetContentsList(owner: string, repo: string, ref?: string, options?: any): AxiosPromise<Array<ContentsResponse>> {
            return RepositoryApiFp(configuration).repoGetContentsList(owner, repo, ref, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get the EditorConfig definitions of a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of file to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetEditorConfig(owner: string, repo: string, filepath: string, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoGetEditorConfig(owner, repo, filepath, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Git hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetGitHook(owner: string, repo: string, id: string, options?: any): AxiosPromise<GitHook> {
            return RepositoryApiFp(configuration).repoGetGitHook(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetHook(owner: string, repo: string, id: number, options?: any): AxiosPromise<Hook> {
            return RepositoryApiFp(configuration).repoGetHook(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get available issue templates for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetIssueTemplates(owner: string, repo: string, options?: any): AxiosPromise<Array<IssueTemplate>> {
            return RepositoryApiFp(configuration).repoGetIssueTemplates(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a repository's key by id
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetKey(owner: string, repo: string, id: number, options?: any): AxiosPromise<DeployKey> {
            return RepositoryApiFp(configuration).repoGetKey(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get languages and number of bytes of code written
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetLanguages(owner: string, repo: string, options?: any): AxiosPromise<{ [key : string]: number;}> {
            return RepositoryApiFp(configuration).repoGetLanguages(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullRequest(owner: string, repo: string, index: number, options?: any): AxiosPromise<PullRequest> {
            return RepositoryApiFp(configuration).repoGetPullRequest(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullReview(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<PullReview> {
            return RepositoryApiFp(configuration).repoGetPullReview(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullReviewComments(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<Array<PullReviewComment>> {
            return RepositoryApiFp(configuration).repoGetPullReviewComments(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a file from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRawFile(owner: string, repo: string, filepath: string, ref?: string, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoGetRawFile(owner, repo, filepath, ref, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRelease(owner: string, repo: string, id: number, options?: any): AxiosPromise<Release> {
            return RepositoryApiFp(configuration).repoGetRelease(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: any): AxiosPromise<Attachment> {
            return RepositoryApiFp(configuration).repoGetReleaseAttachment(owner, repo, id, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReleaseByTag(owner: string, repo: string, tag: string, options?: any): AxiosPromise<Release> {
            return RepositoryApiFp(configuration).repoGetReleaseByTag(owner, repo, tag, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetSingleCommit(owner: string, repo: string, sha: string, options?: any): AxiosPromise<Commit> {
            return RepositoryApiFp(configuration).repoGetSingleCommit(owner, repo, sha, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get specified ref or filtered repository's refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListAllGitRefs(owner: string, repo: string, options?: any): AxiosPromise<Array<Reference>> {
            return RepositoryApiFp(configuration).repoListAllGitRefs(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListBranchProtection(owner: string, repo: string, options?: any): AxiosPromise<Array<BranchProtection>> {
            return RepositoryApiFp(configuration).repoListBranchProtection(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List a repository's branches
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListBranches(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Branch>> {
            return RepositoryApiFp(configuration).repoListBranches(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List a repository's collaborators
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListCollaborators(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return RepositoryApiFp(configuration).repoListCollaborators(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List the Git hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListGitHooks(owner: string, repo: string, options?: any): AxiosPromise<Array<GitHook>> {
            return RepositoryApiFp(configuration).repoListGitHooks(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get specified ref or filtered repository's refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref part or full name of the ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListGitRefs(owner: string, repo: string, ref: string, options?: any): AxiosPromise<Array<Reference>> {
            return RepositoryApiFp(configuration).repoListGitRefs(owner, repo, ref, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List the hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListHooks(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Hook>> {
            return RepositoryApiFp(configuration).repoListHooks(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List a repository's keys
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [keyId] the key_id to search for
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListKeys(owner: string, repo: string, keyId?: number, fingerprint?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<DeployKey>> {
            return RepositoryApiFp(configuration).repoListKeys(owner, repo, keyId, fingerprint, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List a repo's pull requests
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [state] State of pull request: open or closed (optional)
         * @param {string} [sort] Type of sort
         * @param {number} [milestone] ID of the milestone
         * @param {Array&lt;number&gt;} [labels] Label IDs
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPullRequests(owner: string, repo: string, state?: string, sort?: string, milestone?: number, labels?: Array<number>, page?: number, limit?: number, options?: any): AxiosPromise<Array<PullRequest>> {
            return RepositoryApiFp(configuration).repoListPullRequests(owner, repo, state, sort, milestone, labels, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List all reviews for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPullReviews(owner: string, repo: string, index: number, page?: number, limit?: number, options?: any): AxiosPromise<Array<PullReview>> {
            return RepositoryApiFp(configuration).repoListPullReviews(owner, repo, index, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List release's attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListReleaseAttachments(owner: string, repo: string, id: number, options?: any): AxiosPromise<Array<Attachment>> {
            return RepositoryApiFp(configuration).repoListReleaseAttachments(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List a repo's releases
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [perPage] page size of results, deprecated - use limit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListReleases(owner: string, repo: string, perPage?: number, page?: number, limit?: number, options?: any): AxiosPromise<Array<Release>> {
            return RepositoryApiFp(configuration).repoListReleases(owner, repo, perPage, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List a repo's stargazers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStargazers(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return RepositoryApiFp(configuration).repoListStargazers(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a commit's statuses
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {string} [sort] type of sort
         * @param {string} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStatuses(owner: string, repo: string, sha: string, sort?: string, state?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<CommitStatus>> {
            return RepositoryApiFp(configuration).repoListStatuses(owner, repo, sha, sort, state, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a commit's statuses, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {string} [sort] type of sort
         * @param {string} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStatusesByRef(owner: string, repo: string, ref: string, sort?: string, state?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<CommitStatus>> {
            return RepositoryApiFp(configuration).repoListStatusesByRef(owner, repo, ref, sort, state, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List a repo's watchers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListSubscribers(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return RepositoryApiFp(configuration).repoListSubscribers(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List a repository's tags
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results, default maximum page size is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTags(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Tag>> {
            return RepositoryApiFp(configuration).repoListTags(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List a repository's teams
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTeams(owner: string, repo: string, options?: any): AxiosPromise<Array<Team>> {
            return RepositoryApiFp(configuration).repoListTeams(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get list of topics that a repository has
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTopics(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<TopicName> {
            return RepositoryApiFp(configuration).repoListTopics(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Merge a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {MergePullRequestOption} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMergePullRequest(owner: string, repo: string, index: number, body?: MergePullRequestOption, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoMergePullRequest(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Migrate a remote git repository
         * @param {MigrateRepoOptions} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMigrate(body?: MigrateRepoOptions, options?: any): AxiosPromise<Repository> {
            return RepositoryApiFp(configuration).repoMigrate(body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Sync a mirrored repository
         * @param {string} owner owner of the repo to sync
         * @param {string} repo name of the repo to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMirrorSync(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoMirrorSync(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Check if a pull request has been merged
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoPullRequestIsMerged(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoPullRequestIsMerged(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Search for repositories
         * @param {string} [q] keyword
         * @param {boolean} [topic] Limit search to repositories with keyword as topic
         * @param {boolean} [includeDesc] include search of keyword within repository description
         * @param {number} [uid] search only for repos that the user with the given id owns or contributes to
         * @param {number} [priorityOwnerId] repo owner to prioritize in the results
         * @param {number} [teamId] search only for repos that belong to the given team id
         * @param {number} [starredBy] search only for repos that the user with the given id has starred
         * @param {boolean} [_private] include private repositories this user has access to (defaults to true)
         * @param {boolean} [isPrivate] show only pubic, private or all repositories (defaults to all)
         * @param {boolean} [template] include template repositories this user has access to (defaults to true)
         * @param {boolean} [archived] show only archived, non-archived or all repositories (defaults to all)
         * @param {string} [mode] type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
         * @param {boolean} [exclusive] if &#x60;uid&#x60; is given, search only for repos that the user owns
         * @param {string} [sort] sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
         * @param {string} [order] sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSearch(q?: string, topic?: boolean, includeDesc?: boolean, uid?: number, priorityOwnerId?: number, teamId?: number, starredBy?: number, _private?: boolean, isPrivate?: boolean, template?: boolean, archived?: boolean, mode?: string, exclusive?: boolean, sort?: string, order?: string, page?: number, limit?: number, options?: any): AxiosPromise<SearchResults> {
            return RepositoryApiFp(configuration).repoSearch(q, topic, includeDesc, uid, priorityOwnerId, teamId, starredBy, _private, isPrivate, template, archived, mode, exclusive, sort, order, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get signing-key.gpg for given repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSigningKey(owner: string, repo: string, options?: any): AxiosPromise<string> {
            return RepositoryApiFp(configuration).repoSigningKey(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Submit a pending review to an pull request
         * @param {SubmitPullReviewOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSubmitPullReview(body: SubmitPullReviewOptions, owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<PullReview> {
            return RepositoryApiFp(configuration).repoSubmitPullReview(body, owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Test a push webhook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTestHook(owner: string, repo: string, id: number, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoTestHook(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List a repo's tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {Date} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {Date} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTrackedTimes(owner: string, repo: string, user?: string, since?: Date, before?: Date, page?: number, limit?: number, options?: any): AxiosPromise<Array<TrackedTime>> {
            return RepositoryApiFp(configuration).repoTrackedTimes(owner, repo, user, since, before, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Transfer a repo ownership
         * @param {TransferRepoOption} body Transfer Options
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTransfer(body: TransferRepoOption, owner: string, repo: string, options?: any): AxiosPromise<Repository> {
            return RepositoryApiFp(configuration).repoTransfer(body, owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Cancel to dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUnDismissPullReview(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<PullReview> {
            return RepositoryApiFp(configuration).repoUnDismissPullReview(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a file in a repository
         * @param {UpdateFileOptions} body
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdateFile(body: UpdateFileOptions, owner: string, repo: string, filepath: string, options?: any): AxiosPromise<FileResponse> {
            return RepositoryApiFp(configuration).repoUpdateFile(body, owner, repo, filepath, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Merge PR's baseBranch into headBranch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdatePullRequest(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoUpdatePullRequest(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Replace list of topics for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {RepoTopicOptions} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdateTopics(owner: string, repo: string, body?: RepoTopicOptions, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).repoUpdateTopics(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary search topics via keyword
         * @param {string} q keywords to search
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicSearch(q: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<TopicResponse>> {
            return RepositoryApiFp(configuration).topicSearch(q, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Check if the current user is watching a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentCheckSubscription(owner: string, repo: string, options?: any): AxiosPromise<WatchInfo> {
            return RepositoryApiFp(configuration).userCurrentCheckSubscription(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Unwatch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteSubscription(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).userCurrentDeleteSubscription(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Watch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPutSubscription(owner: string, repo: string, options?: any): AxiosPromise<WatchInfo> {
            return RepositoryApiFp(configuration).userCurrentPutSubscription(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List a user's tracked times in a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} user username of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTrackedTimes(owner: string, repo: string, user: string, options?: any): AxiosPromise<Array<TrackedTime>> {
            return RepositoryApiFp(configuration).userTrackedTimes(owner, repo, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoryApi - object-oriented interface
 * @export
 * @class RepositoryApi
 * @extends {BaseAPI}
 */
export class RepositoryApi extends BaseAPI {
    /**
     *
     * @summary Create a repository
     * @param {CreateRepoOption} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public createCurrentUserRepo(body?: CreateRepoOption, options?: any) {
        return RepositoryApiFp(this.configuration).createCurrentUserRepo(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Fork a repository
     * @param {string} owner owner of the repo to fork
     * @param {string} repo name of the repo to fork
     * @param {CreateForkOption} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public createFork(owner: string, repo: string, body?: CreateForkOption, options?: any) {
        return RepositoryApiFp(this.configuration).createFork(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets the blob of a repository.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getBlob(owner: string, repo: string, sha: string, options?: any) {
        return RepositoryApiFp(this.configuration).getBlob(owner, repo, sha, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets the tag object of an annotated tag (not lightweight tags)
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTag(owner: string, repo: string, sha: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTag(owner, repo, sha, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets the tree of a repository.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {boolean} [recursive] show all directories and files
     * @param {number} [page] page number; the &#x27;truncated&#x27; field in the response will be true if there are still more items after this page, false if the last page
     * @param {number} [perPage] number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTree(owner: string, repo: string, sha: string, recursive?: boolean, page?: number, perPage?: number, options?: any) {
        return RepositoryApiFp(this.configuration).getTree(owner, repo, sha, recursive, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List a repository's forks
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public listForks(owner: string, repo: string, page?: number, limit?: number, options?: any) {
        return RepositoryApiFp(this.configuration).listForks(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add a collaborator to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} collaborator username of the collaborator to add
     * @param {AddCollaboratorOption} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoAddCollaborator(owner: string, repo: string, collaborator: string, body?: AddCollaboratorOption, options?: any) {
        return RepositoryApiFp(this.configuration).repoAddCollaborator(owner, repo, collaborator, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add a team to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} team team name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoAddTeam(owner: string, repo: string, team: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoAddTeam(owner, repo, team, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add a topic to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} topic name of the topic to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoAddTopc(owner: string, repo: string, topic: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoAddTopc(owner, repo, topic, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Check if a user is a collaborator of a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} collaborator username of the collaborator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCheckCollaborator(owner: string, repo: string, collaborator: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoCheckCollaborator(owner, repo, collaborator, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Check if a team is assigned to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} team team name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCheckTeam(owner: string, repo: string, team: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoCheckTeam(owner, repo, team, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a branch
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateBranchRepoOption} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateBranch(owner: string, repo: string, body?: CreateBranchRepoOption, options?: any) {
        return RepositoryApiFp(this.configuration).repoCreateBranch(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a branch protections for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateBranchProtectionOption} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateBranchProtection(owner: string, repo: string, body?: CreateBranchProtectionOption, options?: any) {
        return RepositoryApiFp(this.configuration).repoCreateBranchProtection(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a file in a repository
     * @param {CreateFileOptions} body
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the file to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateFile(body: CreateFileOptions, owner: string, repo: string, filepath: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoCreateFile(body, owner, repo, filepath, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a hook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateHookOption} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateHook(owner: string, repo: string, body?: CreateHookOption, options?: any) {
        return RepositoryApiFp(this.configuration).repoCreateHook(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add a key to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateKeyOption} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateKey(owner: string, repo: string, body?: CreateKeyOption, options?: any) {
        return RepositoryApiFp(this.configuration).repoCreateKey(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreatePullRequestOption} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreatePullRequest(owner: string, repo: string, body?: CreatePullRequestOption, options?: any) {
        return RepositoryApiFp(this.configuration).repoCreatePullRequest(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a review to an pull request
     * @param {CreatePullReviewOptions} body
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreatePullReview(body: CreatePullReviewOptions, owner: string, repo: string, index: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoCreatePullReview(body, owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary create review requests for a pull request
     * @param {PullReviewRequestOptions} body
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreatePullReviewRequests(body: PullReviewRequestOptions, owner: string, repo: string, index: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoCreatePullReviewRequests(body, owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateReleaseOption} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateRelease(owner: string, repo: string, body?: CreateReleaseOption, options?: any) {
        return RepositoryApiFp(this.configuration).repoCreateRelease(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a release attachment
     * @param {string} attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {string} [name] name of the attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateReleaseAttachment(attachment: string, owner: string, repo: string, id: number, name?: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoCreateReleaseAttachment(attachment, owner, repo, id, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a commit status
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {CreateStatusOption} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateStatus(owner: string, repo: string, sha: string, body?: CreateStatusOption, options?: any) {
        return RepositoryApiFp(this.configuration).repoCreateStatus(owner, repo, sha, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a repository
     * @param {string} owner owner of the repo to delete
     * @param {string} repo name of the repo to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDelete(owner: string, repo: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoDelete(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a specific branch from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} branch branch to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteBranch(owner: string, repo: string, branch: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoDeleteBranch(owner, repo, branch, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a specific branch protection for the repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name name of protected branch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteBranchProtection(owner: string, repo: string, name: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoDeleteBranchProtection(owner, repo, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a collaborator from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} collaborator username of the collaborator to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteCollaborator(owner: string, repo: string, collaborator: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoDeleteCollaborator(owner, repo, collaborator, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a file in a repository
     * @param {DeleteFileOptions} body
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the file to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteFile(body: DeleteFileOptions, owner: string, repo: string, filepath: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoDeleteFile(body, owner, repo, filepath, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Git hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteGitHook(owner: string, repo: string, id: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoDeleteGitHook(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the hook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteHook(owner: string, repo: string, id: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoDeleteHook(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a key from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the key to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteKey(owner: string, repo: string, id: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoDeleteKey(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a specific review from a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeletePullReview(owner: string, repo: string, index: number, id: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoDeletePullReview(owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary cancel review requests for a pull request
     * @param {PullReviewRequestOptions} body
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeletePullReviewRequests(body: PullReviewRequestOptions, owner: string, repo: string, index: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoDeletePullReviewRequests(body, owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteRelease(owner: string, repo: string, id: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoDeleteRelease(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a release attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {number} attachmentId id of the attachment to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoDeleteReleaseAttachment(owner, repo, id, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a release by tag name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag tag name of the release to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteReleaseByTag(owner: string, repo: string, tag: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoDeleteReleaseByTag(owner, repo, tag, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a repository's tag by name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag name of tag to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteTag(owner: string, repo: string, tag: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoDeleteTag(owner, repo, tag, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a team from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} team team name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteTeam(owner: string, repo: string, team: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoDeleteTeam(owner, repo, team, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a topic from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} topic name of the topic to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteTopic(owner: string, repo: string, topic: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoDeleteTopic(owner, repo, topic, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Dismiss a review for a pull request
     * @param {DismissPullReviewOptions} body
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDismissPullReview(body: DismissPullReviewOptions, owner: string, repo: string, index: number, id: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoDismissPullReview(body, owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a pull request diff
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDownloadPullDiff(owner: string, repo: string, index: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoDownloadPullDiff(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a pull request patch file
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDownloadPullPatch(owner: string, repo: string, index: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoDownloadPullPatch(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Edit a repository's properties. Only fields that are set will be changed.
     * @param {string} owner owner of the repo to edit
     * @param {string} repo name of the repo to edit
     * @param {EditRepoOption} [body] Properties of a repo that you can edit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEdit(owner: string, repo: string, body?: EditRepoOption, options?: any) {
        return RepositoryApiFp(this.configuration).repoEdit(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Edit a branch protections for a repository. Only fields that are set will be changed
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name name of protected branch
     * @param {EditBranchProtectionOption} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditBranchProtection(owner: string, repo: string, name: string, body?: EditBranchProtectionOption, options?: any) {
        return RepositoryApiFp(this.configuration).repoEditBranchProtection(owner, repo, name, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Edit a Git hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id id of the hook to get
     * @param {EditGitHookOption} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditGitHook(owner: string, repo: string, id: string, body?: EditGitHookOption, options?: any) {
        return RepositoryApiFp(this.configuration).repoEditGitHook(owner, repo, id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Edit a hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id index of the hook
     * @param {EditHookOption} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditHook(owner: string, repo: string, id: number, body?: EditHookOption, options?: any) {
        return RepositoryApiFp(this.configuration).repoEditHook(owner, repo, id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to edit
     * @param {EditPullRequestOption} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditPullRequest(owner: string, repo: string, index: number, body?: EditPullRequestOption, options?: any) {
        return RepositoryApiFp(this.configuration).repoEditPullRequest(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release to edit
     * @param {EditReleaseOption} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditRelease(owner: string, repo: string, id: number, body?: EditReleaseOption, options?: any) {
        return RepositoryApiFp(this.configuration).repoEditRelease(owner, repo, id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Edit a release attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {number} attachmentId id of the attachment to edit
     * @param {EditAttachmentOptions} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: any) {
        return RepositoryApiFp(this.configuration).repoEditReleaseAttachment(owner, repo, id, attachmentId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGet(owner: string, repo: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoGet(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a list of all commits from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [sha] SHA or branch to start listing commits from (usually &#x27;master&#x27;)
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetAllCommits(owner: string, repo: string, sha?: string, page?: number, limit?: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoGetAllCommits(owner, repo, sha, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get an archive of a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} archive the git reference for download with attached archive format (e.g. master.zip)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetArchive(owner: string, repo: string, archive: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoGetArchive(owner, repo, archive, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a specific branch from a repository, including its effective branch protection
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} branch branch to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetBranch(owner: string, repo: string, branch: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoGetBranch(owner, repo, branch, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a specific branch protection for the repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name name of protected branch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetBranchProtection(owner: string, repo: string, name: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoGetBranchProtection(owner, repo, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a repository by id
     * @param {number} id id of the repo to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetByID(id: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoGetByID(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a commit's combined status, by branch/tag/commit reference
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} ref name of branch/tag/commit
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetCombinedStatusByRef(owner: string, repo: string, ref: string, page?: number, limit?: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoGetCombinedStatusByRef(owner, repo, ref, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the dir, file, symlink or submodule in the repo
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetContents(owner: string, repo: string, filepath: string, ref?: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoGetContents(owner, repo, filepath, ref, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets the metadata of all the entries of the root dir
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetContentsList(owner: string, repo: string, ref?: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoGetContentsList(owner, repo, ref, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get the EditorConfig definitions of a file in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath filepath of file to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetEditorConfig(owner: string, repo: string, filepath: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoGetEditorConfig(owner, repo, filepath, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Git hook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetGitHook(owner: string, repo: string, id: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoGetGitHook(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a hook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetHook(owner: string, repo: string, id: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoGetHook(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get available issue templates for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetIssueTemplates(owner: string, repo: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoGetIssueTemplates(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a repository's key by id
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the key to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetKey(owner: string, repo: string, id: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoGetKey(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get languages and number of bytes of code written
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetLanguages(owner: string, repo: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoGetLanguages(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetPullRequest(owner: string, repo: string, index: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoGetPullRequest(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a specific review for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetPullReview(owner: string, repo: string, index: number, id: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoGetPullReview(owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a specific review for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetPullReviewComments(owner: string, repo: string, index: number, id: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoGetPullReviewComments(owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a file from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath filepath of the file to get
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetRawFile(owner: string, repo: string, filepath: string, ref?: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoGetRawFile(owner, repo, filepath, ref, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetRelease(owner: string, repo: string, id: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoGetRelease(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a release attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {number} attachmentId id of the attachment to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoGetReleaseAttachment(owner, repo, id, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a release by tag name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag tag name of the release to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetReleaseByTag(owner: string, repo: string, tag: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoGetReleaseByTag(owner, repo, tag, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a single commit from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha a git ref or commit sha
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetSingleCommit(owner: string, repo: string, sha: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoGetSingleCommit(owner, repo, sha, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get specified ref or filtered repository's refs
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListAllGitRefs(owner: string, repo: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoListAllGitRefs(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List branch protections for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListBranchProtection(owner: string, repo: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoListBranchProtection(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List a repository's branches
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListBranches(owner: string, repo: string, page?: number, limit?: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoListBranches(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List a repository's collaborators
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListCollaborators(owner: string, repo: string, page?: number, limit?: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoListCollaborators(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List the Git hooks in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListGitHooks(owner: string, repo: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoListGitHooks(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get specified ref or filtered repository's refs
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} ref part or full name of the ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListGitRefs(owner: string, repo: string, ref: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoListGitRefs(owner, repo, ref, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List the hooks in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListHooks(owner: string, repo: string, page?: number, limit?: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoListHooks(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List a repository's keys
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [keyId] the key_id to search for
     * @param {string} [fingerprint] fingerprint of the key
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListKeys(owner: string, repo: string, keyId?: number, fingerprint?: string, page?: number, limit?: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoListKeys(owner, repo, keyId, fingerprint, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List a repo's pull requests
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [state] State of pull request: open or closed (optional)
     * @param {string} [sort] Type of sort
     * @param {number} [milestone] ID of the milestone
     * @param {Array&lt;number&gt;} [labels] Label IDs
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListPullRequests(owner: string, repo: string, state?: string, sort?: string, milestone?: number, labels?: Array<number>, page?: number, limit?: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoListPullRequests(owner, repo, state, sort, milestone, labels, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List all reviews for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListPullReviews(owner: string, repo: string, index: number, page?: number, limit?: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoListPullReviews(owner, repo, index, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List release's attachments
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListReleaseAttachments(owner: string, repo: string, id: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoListReleaseAttachments(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List a repo's releases
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [perPage] page size of results, deprecated - use limit
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListReleases(owner: string, repo: string, perPage?: number, page?: number, limit?: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoListReleases(owner, repo, perPage, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List a repo's stargazers
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListStargazers(owner: string, repo: string, page?: number, limit?: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoListStargazers(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a commit's statuses
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {string} [sort] type of sort
     * @param {string} [state] type of state
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListStatuses(owner: string, repo: string, sha: string, sort?: string, state?: string, page?: number, limit?: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoListStatuses(owner, repo, sha, sort, state, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a commit's statuses, by branch/tag/commit reference
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} ref name of branch/tag/commit
     * @param {string} [sort] type of sort
     * @param {string} [state] type of state
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListStatusesByRef(owner: string, repo: string, ref: string, sort?: string, state?: string, page?: number, limit?: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoListStatusesByRef(owner, repo, ref, sort, state, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List a repo's watchers
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListSubscribers(owner: string, repo: string, page?: number, limit?: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoListSubscribers(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List a repository's tags
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results, default maximum page size is 50
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListTags(owner: string, repo: string, page?: number, limit?: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoListTags(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List a repository's teams
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListTeams(owner: string, repo: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoListTeams(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get list of topics that a repository has
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListTopics(owner: string, repo: string, page?: number, limit?: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoListTopics(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Merge a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to merge
     * @param {MergePullRequestOption} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoMergePullRequest(owner: string, repo: string, index: number, body?: MergePullRequestOption, options?: any) {
        return RepositoryApiFp(this.configuration).repoMergePullRequest(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Migrate a remote git repository
     * @param {MigrateRepoOptions} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoMigrate(body?: MigrateRepoOptions, options?: any) {
        return RepositoryApiFp(this.configuration).repoMigrate(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Sync a mirrored repository
     * @param {string} owner owner of the repo to sync
     * @param {string} repo name of the repo to sync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoMirrorSync(owner: string, repo: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoMirrorSync(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Check if a pull request has been merged
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoPullRequestIsMerged(owner: string, repo: string, index: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoPullRequestIsMerged(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Search for repositories
     * @param {string} [q] keyword
     * @param {boolean} [topic] Limit search to repositories with keyword as topic
     * @param {boolean} [includeDesc] include search of keyword within repository description
     * @param {number} [uid] search only for repos that the user with the given id owns or contributes to
     * @param {number} [priorityOwnerId] repo owner to prioritize in the results
     * @param {number} [teamId] search only for repos that belong to the given team id
     * @param {number} [starredBy] search only for repos that the user with the given id has starred
     * @param {boolean} [_private] include private repositories this user has access to (defaults to true)
     * @param {boolean} [isPrivate] show only pubic, private or all repositories (defaults to all)
     * @param {boolean} [template] include template repositories this user has access to (defaults to true)
     * @param {boolean} [archived] show only archived, non-archived or all repositories (defaults to all)
     * @param {string} [mode] type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
     * @param {boolean} [exclusive] if &#x60;uid&#x60; is given, search only for repos that the user owns
     * @param {string} [sort] sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
     * @param {string} [order] sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoSearch(q?: string, topic?: boolean, includeDesc?: boolean, uid?: number, priorityOwnerId?: number, teamId?: number, starredBy?: number, _private?: boolean, isPrivate?: boolean, template?: boolean, archived?: boolean, mode?: string, exclusive?: boolean, sort?: string, order?: string, page?: number, limit?: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoSearch(q, topic, includeDesc, uid, priorityOwnerId, teamId, starredBy, _private, isPrivate, template, archived, mode, exclusive, sort, order, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get signing-key.gpg for given repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoSigningKey(owner: string, repo: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoSigningKey(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Submit a pending review to an pull request
     * @param {SubmitPullReviewOptions} body
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoSubmitPullReview(body: SubmitPullReviewOptions, owner: string, repo: string, index: number, id: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoSubmitPullReview(body, owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Test a push webhook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the hook to test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoTestHook(owner: string, repo: string, id: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoTestHook(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List a repo's tracked times
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [user] optional filter by user (available for issue managers)
     * @param {Date} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
     * @param {Date} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoTrackedTimes(owner: string, repo: string, user?: string, since?: Date, before?: Date, page?: number, limit?: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoTrackedTimes(owner, repo, user, since, before, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Transfer a repo ownership
     * @param {TransferRepoOption} body Transfer Options
     * @param {string} owner owner of the repo to transfer
     * @param {string} repo name of the repo to transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoTransfer(body: TransferRepoOption, owner: string, repo: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoTransfer(body, owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Cancel to dismiss a review for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoUnDismissPullReview(owner: string, repo: string, index: number, id: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoUnDismissPullReview(owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a file in a repository
     * @param {UpdateFileOptions} body
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the file to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoUpdateFile(body: UpdateFileOptions, owner: string, repo: string, filepath: string, options?: any) {
        return RepositoryApiFp(this.configuration).repoUpdateFile(body, owner, repo, filepath, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Merge PR's baseBranch into headBranch
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoUpdatePullRequest(owner: string, repo: string, index: number, options?: any) {
        return RepositoryApiFp(this.configuration).repoUpdatePullRequest(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Replace list of topics for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {RepoTopicOptions} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoUpdateTopics(owner: string, repo: string, body?: RepoTopicOptions, options?: any) {
        return RepositoryApiFp(this.configuration).repoUpdateTopics(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary search topics via keyword
     * @param {string} q keywords to search
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public topicSearch(q: string, page?: number, limit?: number, options?: any) {
        return RepositoryApiFp(this.configuration).topicSearch(q, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Check if the current user is watching a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public userCurrentCheckSubscription(owner: string, repo: string, options?: any) {
        return RepositoryApiFp(this.configuration).userCurrentCheckSubscription(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Unwatch a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public userCurrentDeleteSubscription(owner: string, repo: string, options?: any) {
        return RepositoryApiFp(this.configuration).userCurrentDeleteSubscription(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Watch a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public userCurrentPutSubscription(owner: string, repo: string, options?: any) {
        return RepositoryApiFp(this.configuration).userCurrentPutSubscription(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List a user's tracked times in a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} user username of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public userTrackedTimes(owner: string, repo: string, user: string, options?: any) {
        return RepositoryApiFp(this.configuration).userTrackedTimes(owner, repo, user, options).then((request) => request(this.axios, this.basePath));
    }
}
